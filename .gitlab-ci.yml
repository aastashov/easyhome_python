image: docker:19.03.8

services:
  - docker:19.03.8-dind

variables:
  CONTAINER_NAME_BOT: my_house_bot
  CONTAINER_NAME_API: my_house_api

  CI_REGISTRY_IMAGE_API: ${CI_REGISTRY_IMAGE}/api

# Define the next environments in your CI/CD
# SSH_PRIVATE_KEY: <ssh key for STAGING_DEPLOY_HOST and PROD_DEPLOY_HOST>
# DEPLOY_USER: gitlab
# STAGING_DEPLOY_HOST: staging.example.com
# PROD_DEPLOY_HOST: example.com
# PROD_API_PARAMS: -e VAR=val -e VAR2=val2
# PROD_BOT_PARAMS: -e VAR=val -e VAR2=val2
# STAGING_API_PARAMS: -e VAR=val -e VAR2=val2
# STAGING_BOT_PARAMS: -e VAR=val -e VAR2=val2

.use-ssh: &script-use-ssh
  - 'which ssh-agent || ( apk add openssh-client )'
  - eval $(ssh-agent -s)
  - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
  - mkdir -p ~/.ssh && chmod 700 ~/.ssh

.deploy: &script-deploy
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  - ssh -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "docker pull $CI_REGISTRY_IMAGE:v.$CI_PIPELINE_IID"
  - ssh -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "docker pull $CI_REGISTRY_IMAGE_API:v.$CI_PIPELINE_IID"
  - ssh -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "docker rm -f $CONTAINER_NAME_BOT || true && docker run -d --name=$CONTAINER_NAME_BOT --restart=always --log-driver=syslog --log-opt tag=docker/$CONTAINER_NAME_BOT $PARAMS_BOT $CI_REGISTRY_IMAGE:v.$CI_PIPELINE_IID"
  - ssh -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "docker rm -f $CONTAINER_NAME_API || true && docker run -d --name=$CONTAINER_NAME_API --restart=always --log-driver=syslog --log-opt tag=docker/$CONTAINER_NAME_API $PARAMS_API $CI_REGISTRY_IMAGE_API:v.$CI_PIPELINE_IID"

stages:
#  - Start unit tests
  - Build docker images
  - Deploy to staging
#  - Deploy to production

#testing:
#  image: docker/compose:1.25.0-rc2
#  stage: Start unit tests
#  script:
#    - <tests in docker>

bot_release:
  stage: Build docker images
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker pull $CI_REGISTRY_IMAGE:latest || true
    - cd parser/ && docker build --cache-from $CI_REGISTRY_IMAGE:latest --build-arg RELEASE=v.$CI_PIPELINE_IID --tag $CI_REGISTRY_IMAGE:v.$CI_PIPELINE_IID --tag $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:v.$CI_PIPELINE_IID
    - docker push $CI_REGISTRY_IMAGE:latest

api_release:
  stage: Build docker images
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker pull $CI_REGISTRY_IMAGE_API:latest || true
    - cd api/ && docker build --cache-from $CI_REGISTRY_IMAGE_API:latest --build-arg RELEASE=v.$CI_PIPELINE_IID --tag $CI_REGISTRY_IMAGE_API:v.$CI_PIPELINE_IID --tag $CI_REGISTRY_IMAGE_API:latest .
    - docker push $CI_REGISTRY_IMAGE_API:v.$CI_PIPELINE_IID
    - docker push $CI_REGISTRY_IMAGE_API:latest

staging:
  variables:
    PARAMS_API: $STAGING_API_PARAMS
    PARAMS_BOT: $STAGING_BOT_PARAMS
    DEPLOY_HOST: $STAGING_DEPLOY_HOST
  stage: Deploy to staging
  script:
    - *script-use-ssh
    - *script-deploy
  only:
    - dev

#production:
#  variables:
#    PARAMS_API: $PROD_API_PARAMS
#    PARAMS_BOT: $PROD_BOT_PARAMS
#    DEPLOY_HOST: $PROD_DEPLOY_HOST
#  stage: Deploy to production
#  script:
#    - *script-use-ssh
#    - *script-deploy
#  when: manual
#  only:
#    - master
